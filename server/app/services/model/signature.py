import codecs
import logging
import math
import os
from pathlib import Path
from typing import Tuple

from azure.identity import ManagedIdentityCredential
from azure.keyvault.keys import KeyClient
from azure.keyvault.keys.crypto import CryptographyClient, SignatureAlgorithm
from cryptography.exceptions import InvalidSignature
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import ec, utils
from cryptography.utils import int_to_bytes

from app.core.config import settings

KEY_PUBLIC_NUMBERS_X_COMPONENT = "KEY_PUBLIC_NUMBERS_X_COMPONENT"
KEY_PUBLIC_NUMBERS_Y_COMPONENT = "KEY_PUBLIC_NUMBERS_Y_COMPONENT"
# For use in dev environments only.
KEY_PRIVATE_NUMBER_COMPONENT = "KEY_PRIVATE_NUMBER_COMPONENT"
PRIVATE_KEY_PATH = "./dev_assets/local-dev-signing.key"

logger = logging.getLogger(__name__)
signature_algorithm = ec.SECP256K1()


def sign(row_hash: bytes) -> str:
    """Signs a row."""
    if settings.DEBUG:
        # For dev environments we generate a local key and sign the rows locally
        return _sign_local(row_hash)

    crypto_client = _kv_crypto_client()
    result = crypto_client.sign(SignatureAlgorithm.es256_k, row_hash)
    logger.debug("Database row's signature was successfully created using KV.")
    return result.signature.hex()


def verify(row_hash: bytes, signature: bytes) -> None:
    try:
        _verify_local(row_hash, signature)
    except InvalidSignature as e:
        raise e
    except Exception as e:
        if settings.DEBUG:
            raise e
        logger.debug(f"Failed to verify signature locally with error: {e}, trying key vault.")
        _verify_kv(row_hash, signature)


def _verify_local(row_hash: bytes, signature: bytes) -> None:
    x = int(os.environ.get(KEY_PUBLIC_NUMBERS_X_COMPONENT, "0"))
    y = int(os.environ.get(KEY_PUBLIC_NUMBERS_Y_COMPONENT, "0"))

    if not x or not y:
        if settings.DEBUG:
            # For dev environments we generate a local key and sign the rows locally.
            _, x, y = _populate_local_signing_key(generate=False)
        else:
            # For non-dev, verify using key vault which also populates the env vars.
            return _verify_kv(row_hash, signature)

    ec_key = ec.EllipticCurvePublicNumbers(x, y, signature_algorithm).public_key()
    ec_key.verify(
        _ecdsa_to_asn1_der(signature),
        row_hash,
        ec.ECDSA(utils.Prehashed(hashes.SHA256())),
    )
    logger.debug("Database row's signature was successfully verified locally.")


def _verify_kv(row_hash: bytes, signature: bytes) -> None:
    crypto_client = _kv_crypto_client()
    result = crypto_client.verify(
        SignatureAlgorithm.es256_k,
        row_hash,
        signature,
    )

    if not result.is_valid:
        raise InvalidSignature()
    logger.debug("Database row's signature was successfully verified using key vault.")


def _sign_local(row_hash: bytes) -> str:
    private_key, _, _ = _populate_local_signing_key()

    # Sign the payload file.
    signature = private_key.sign(
        row_hash,
        ec.ECDSA(utils.Prehashed(hashes.SHA256())),
    )

    logger.debug("Database row's signature was successfully created locally.")
    return _asn1_der_to_ecdsa(signature).hex()


def _ecdsa_to_asn1_der(signature: bytes) -> bytes:
    """ASN.1 DER encode an ECDSA signature.

    :param bytes signature: ECDSA signature encoded according to RFC 7518, i.e. the concatenated
    big-endian bytes of two integers (as produced by Key Vault)
    :return: signature, ASN.1 DER encoded (as expected by ``cryptography``)
    """
    mid = len(signature) // 2
    r = _bytes_to_int(signature[:mid])
    s = _bytes_to_int(signature[mid:])
    return utils.encode_dss_signature(r, s)


def _asn1_der_to_ecdsa(signature: bytes) -> bytes:
    """ECDSA encode an ASN.1 DER signature.

    :param bytes signature: ASN.1 DER encoded (as generated by ``cryptography``)
    :return: signature, ECDSA signature encoded according to RFC 7518, i.e. the concatenated
    big-endian bytes of two integers (as produced by Key Vault)
    """
    r, s = utils.decode_dss_signature(signature)
    component_length = int(math.ceil(signature_algorithm.key_size / 8.0))
    return int_to_bytes(r, component_length) + int_to_bytes(s, component_length)


def _bytes_to_int(b: bytes) -> int:
    if not b or not isinstance(b, bytes):
        raise ValueError("b must be non-empty byte string")

    return int(codecs.encode(b, "hex"), 16)


def _kv_crypto_client() -> CryptographyClient:
    # Pass the MSI client id in case there are multiple identities assigned to the resource.
    credential = ManagedIdentityCredential(client_id=settings.AZURE_CLIENT_ID)
    key_client = KeyClient(
        vault_url=f"https://{settings.KEYVAULT}.vault.azure.net/",
        credential=credential,
    )
    key = key_client.get_key(settings.DB_SIGNING_KEY)
    os.environ[KEY_PUBLIC_NUMBERS_X_COMPONENT] = str(_bytes_to_int(getattr(key.key, "x")))
    os.environ[KEY_PUBLIC_NUMBERS_Y_COMPONENT] = str(_bytes_to_int(getattr(key.key, "y")))
    return CryptographyClient(key, credential=credential)


def _populate_local_signing_key(
    generate: bool = True,
) -> Tuple[ec.EllipticCurvePrivateKey, int, int]:
    key_path = Path(PRIVATE_KEY_PATH)
    if key_path.is_file():
        # Load the private key.
        with key_path.open("r") as key_file:
            private_value = key_file.read()
            private_key = ec.derive_private_key(
                int(private_value),
                signature_algorithm,
                backend=default_backend(),
            )
    else:
        if not generate:
            raise FileNotFoundError("Couldn't load private key file for signature verification.")

        private_key = ec.generate_private_key(
            signature_algorithm,
            backend=default_backend(),
        )

        # Save the private key to a file.
        key_path.parent.mkdir(parents=True, exist_ok=True)
        with key_path.open("w") as f:
            f.write(str(private_key.private_numbers().private_value))

    public_key_numbers = private_key.public_key().public_numbers()
    os.environ[KEY_PUBLIC_NUMBERS_X_COMPONENT] = str(public_key_numbers.x)
    os.environ[KEY_PUBLIC_NUMBERS_Y_COMPONENT] = str(public_key_numbers.y)

    return private_key, public_key_numbers.x, public_key_numbers.y
