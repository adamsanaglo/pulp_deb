From 680375590716c173fc3dd593395647e28e62a6fc Mon Sep 17 00:00:00 2001
From: Stephen Herr <stephenherr@microsoft.com>
Date: Wed, 28 Sep 2022 12:10:02 -0400
Subject: [PATCH] Add filters to select by related pulp_deb content types

closes #646
---
 pulp_deb/app/viewsets/content.py | 153 ++++++++++++++++++++++++++++++-
 1 file changed, 152 insertions(+), 1 deletion(-)

diff --git a/pulp_deb/app/viewsets/content.py b/pulp_deb/app/viewsets/content.py
index a2e14d5..c549312 100644
--- a/pulp_deb/app/viewsets/content.py
+++ b/pulp_deb/app/viewsets/content.py
@@ -1,8 +1,12 @@
 from gettext import gettext as _  # noqa
 
+from django_filters import Filter
+from pulpcore.plugin.models import Repository, RepositoryVersion
+from pulpcore.plugin.serializers.content import ValidationError
 from pulpcore.plugin.viewsets import (
-    ContentViewSet,
     ContentFilter,
+    ContentViewSet,
+    NamedModelViewSet,
     SingleArtifactContentUploadViewSet,
 )
 
@@ -36,11 +40,134 @@ class GenericContentViewSet(SingleArtifactContentUploadViewSet):
     filterset_class = GenericContentFilter
 
 
+class ContentRelationshipFilter(Filter):
+    """
+    Base class for filters that allow you to ask meaningful questions about the relationships of
+    deb-specific content types. Subclasses must provide a HELP message and implement _filter.
+
+    The value for all these filters is a string that is a comma-separated 2-tuple, where the second
+    value is the HREF of the RepositoryVersion you care about. This is logically necessary if you
+    want to ask any question beyond "list Package|ReleaseComponent|whatever that were ever at any
+    point in this Repository|Release|whatever". I will try to explain by example.
+
+    Question: "What Packages are in the most recent RepositoryVersion of a Release?"
+
+    Imagine we have a very simple repo with two packages and two releases, and this state is stored
+    in RepositoryVersion1:
+    Repository -> Release1 -> ReleaseComponent1 -> PackageReleaseComponent1 -> Package1
+                                                -> PackageReleaseComponent2 -> Package2
+               -> Release2 -> ReleaseComponent2 -> PackageReleaseComponent3 -> Package2
+
+    We then update the repo to remove Package2 from ReleaseComponent1 and this state gets stored
+    in RepositoryVersion2:
+    Repository -> Release1 -> ReleaseComponent1 -> PackageReleaseComponent1 -> Package1
+               -> Release2 -> ReleaseComponent2 -> PackageReleaseComponent3 -> Package2
+
+    We could try answer the question using the existing ContentFilter.repository_version filter in
+    conjunction with a new filter that naively follows the foreign key references in the database:
+    packages.filter(deb_packagereleasecomponent__release_component__release=release_uuid)
+
+    What Django does if you call two separate filters is use the first to filter the QuerySet,
+    then use the second to filter the QuerySet further. This is *different* than calling
+    filter once with both conditions.
+    https://docs.djangoproject.com/en/dev/topics/db/queries/#spanning-multi-valued-relationships
+
+    Example: packages.filter("in RepositoryVersion2").filter("in Release1")
+    This will return both Package1 and Package2, which is not what we wanted. In the first filter it
+    looks and says "yep, both Package1 and Package2 are in RepositoryVersion2", and then the second
+    filter is applied and it says "yep, both Package1 and Package2 were in Release1 at some point".
+    This is because the linkage via PackageReleaseComponent2 still *exists*, it's just not in
+    RepositoryVersion2.
+
+    What we really _actually_ want is to apply _both_ conditions to the PackageReleaseComponent
+    mapping as an intermediate step, so both release_uuid and repository_version_href must be
+    passed to our new filter:
+    packages.filter(package.PRC in PRC.filter("in RepositoryVersion2", "in Release1"))
+
+    This guarantees that we are only considering Packages with both requirements, and returns only
+    Package1.
+    """
+
+    HELP = "Override with your value-specific help message"
+    ARG = "Override with the type of your arg, for example package_href"
+    GENERIC_HELP = """
+    Must be a comma-separated string: "{arg},repository_or_repository_version_href"
+    {arg}: {help}
+    repository_or_repository_version_href: The RepositoryVersion href to filter by, or Repository
+        href (assume latest version)
+    """
+
+    def __init__(self, *args, **kwargs):
+        kwargs.setdefault(
+            "help_text", _(self.GENERIC_HELP).format(arg=_(self.ARG), help=_(self.HELP))
+        )
+        super().__init__(*args, **kwargs)
+
+    def filter(self, qs, value):
+        """
+        Args:
+            qs (django.db.models.query.QuerySet): The Content Queryset
+            value (string, "value,repository_version_href"): The values to filter by
+        """
+        if value is None:
+            # user didn't supply a value
+            return qs
+
+        repo_version = None
+        my_value, r_or_rv_href = value.split(",", 1)
+        if not my_value or not r_or_rv_href or "," in r_or_rv_href:
+            raise ValidationError(detail=_("Invalid value supplied for content filter"))
+
+        repo_version = NamedModelViewSet.get_resource(r_or_rv_href)
+        if isinstance(repo_version, Repository):
+            repo_version = repo_version.latest_version()
+
+        if not isinstance(repo_version, RepositoryVersion):
+            raise ValidationError(detail=_("Invalid value supplied for content filter"))
+
+        prc_qs = models.PackageReleaseComponent.objects.filter(pk__in=repo_version.content)
+
+        return self._filter(qs, my_value, prc_qs)
+
+    def _filter(self, qs, value, prc_qs):
+        """
+        Args:
+            qs (django.db.models.query.QuerySet): The Content Queryset
+            value (string): The values to filter by
+            prc_qs (django.db.models.query.QuerySet): QuerySet of PackageReleaseComponents in
+                requested RepositoryVersion
+        """
+        raise NotImplementedError
+
+
+class PackageToReleaseComponentFilter(ContentRelationshipFilter):
+    HELP = "Filter results where Package in ReleaseComponent"
+    ARG = "release_component_href"
+
+    def _filter(self, qs, value, prc_qs):
+        rc = NamedModelViewSet.get_resource(value, models.structure_content.ReleaseComponent)
+        prc_qs = prc_qs.filter(release_component__pk=rc.pk)
+        return qs.filter(deb_packagereleasecomponent__in=prc_qs)
+
+
+class PackageToReleaseFilter(ContentRelationshipFilter):
+    HELP = "Filter results where Package in Release"
+    ARG = "release_href"
+
+    def _filter(self, qs, value, prc_qs):
+        r = NamedModelViewSet.get_resource(value, models.structure_content.Release)
+        prc_qs = prc_qs.filter(release_component__release__pk=r.pk)
+        return qs.filter(deb_packagereleasecomponent__in=prc_qs)
+
+
 class PackageFilter(ContentFilter):
     """
     FilterSet for Package.
     """
 
+    release_component = PackageToReleaseComponentFilter()
+    release = PackageToReleaseFilter()
+
     class Meta:
         model = models.Package
         fields = [
@@ -215,11 +342,23 @@ class InstallerFileIndexViewSet(ContentViewSet):
     filterset_class = InstallerFileIndexFilter
 
 
+class ReleaseToPackageFilter(ContentRelationshipFilter):
+    HELP = "Filter results where Release contains Package"
+    ARG = "package_href"
+
+    def _filter(self, qs, value, prc_qs):
+        p = NamedModelViewSet.get_resource(value, models.content.Package)
+        prc_qs = prc_qs.filter(package__pk=p.pk)
+        return qs.filter(deb_releasecomponent__deb_packagereleasecomponent__in=prc_qs)
+
+
 class ReleaseFilter(ContentFilter):
     """
     FilterSet for Release.
     """
 
+    package = ReleaseToPackageFilter()
+
     class Meta:
         model = models.Release
         fields = ["codename", "suite", "distribution"]
@@ -272,11 +411,23 @@ class ReleaseArchitectureViewSet(ContentViewSet):
     filterset_class = ReleaseArchitectureFilter
 
 
+class ReleaseComponentToPackageFilter(ContentRelationshipFilter):
+    HELP = "Filter results where ReleaseComponent contains Package"
+    ARG = "package_href"
+
+    def _filter(self, qs, value, prc_qs):
+        p = NamedModelViewSet.get_resource(value, models.content.Package)
+        prc_qs = prc_qs.filter(package__pk=p.pk)
+        return qs.filter(deb_packagereleasecomponent__in=prc_qs)
+
+
 class ReleaseComponentFilter(ContentFilter):
     """
     FilterSet for ReleaseComponent.
     """
 
+    package = ReleaseComponentToPackageFilter()
+
     class Meta:
         model = models.ReleaseComponent
         fields = ["component", "release"]
-- 
2.31.1

