From fbe85afdc596087d16444c1c3ead34cf7ea49c2d Mon Sep 17 00:00:00 2001
From: Mark Asselstine <mark.asselstine@windriver.com>
Date: Wed, 2 Jun 2021 19:33:20 -0400
Subject: [PATCH] Initial source package and source indices support

fixes #409
https://github.com/pulp/pulp_deb/issues/409
(was https://pulp.plan.io/issues/8775)

Allows the addition of Debian Source Packages, DSC files and any
associate source files (.orig.tar.gz, .debian.tar.xz, ...), as well as
synchronizing with a remote's source indices (sync_sources=True).
Publishing a distribution will make available DSC files, sources and
source indices in the repository, compliant with the Debian
rempository format.

The source files referenced in a dsc_file must be uploaded as
artifacts before the dsc_file so a typical workflow might be

--
apt-get source bc

http --form post $BASE/pulp/api/v3/artifacts/ \
  file@"/tmp/bc_1.07.1-2build1.debian.tar.xz"
http --form post $BASE/pulp/api/v3/artifacts/ \
  file@"/tmp/bc_1.07.1.orig.tar.gz"
http --form post $BASE/pulp/api/v3/artifacts/ \
  file@"/tmp/bc_1.07.1-2build1.dsc"
http --form post $BASE/pulp/api/v3/content/deb/source_packages/ \
  artifact=/pulp/api/v3/artifacts/3094de7e-da61-4cf6-ae75-a35b74472d9a/
--

Attempting to create the source_packages content from a DSC file
artifact before its source files are present as artifacts will result
validation errors.

Once source_packages content has been created it can be inspected via
its pulp_href or using the source_packages endpoint

http get $BASE/pulp/api/v3/content/deb/source_packages/

Synchronizing with a remote with "sync_sources=True" will synchronize
the Source Indicies files inspecting each contained paragraph to
download all associated DSC files and referced source files (note:
source file download may be deferred if remote policy="on_demand"),
performing a high level of data validation and creating all required
associations. As with uploading inspecting contents after a sync is
complete can be done with the same endpoints as above.

To remain spec compliant with https://wiki.debian.org/DebianRepository
"md5" must be present in the ALLOWED_CONTENT_CHECKSUMS. In all cases
the use of md5 is supplemental so security concerns around this
addition, at least for use with this feature, should be minimal.
---
 CHANGES/409.feature                           |   1 +
 ...cepackage_sourcepackagereleasecomponent.py |  82 ++++
 pulp_deb/app/models/__init__.py               |   4 +-
 pulp_deb/app/models/content.py                | 170 ++++++-
 pulp_deb/app/models/metadata_content.py       |  30 ++
 pulp_deb/app/models/repository.py             |   6 +
 pulp_deb/app/models/structure_content.py      |  20 +-
 pulp_deb/app/serializers/__init__.py          |   4 +
 .../app/serializers/content_serializers.py    | 439 +++++++++++++++++-
 pulp_deb/app/tasks/publishing.py              |  69 ++-
 pulp_deb/app/tasks/synchronizing.py           | 132 +++++-
 pulp_deb/app/viewsets/__init__.py             |   3 +
 pulp_deb/app/viewsets/content.py              | 109 +++++
 13 files changed, 1062 insertions(+), 7 deletions(-)
 create mode 100644 CHANGES/409.feature
 create mode 100644 pulp_deb/app/migrations/0020_sourceindex_sourcepackage_sourcepackagereleasecomponent.py

diff --git a/CHANGES/409.feature b/CHANGES/409.feature
new file mode 100644
index 0000000..fddfe71
--- /dev/null
+++ b/CHANGES/409.feature
@@ -0,0 +1 @@
+Add support for handling source packages.
\ No newline at end of file
diff --git a/pulp_deb/app/migrations/0020_sourceindex_sourcepackage_sourcepackagereleasecomponent.py b/pulp_deb/app/migrations/0020_sourceindex_sourcepackage_sourcepackagereleasecomponent.py
new file mode 100644
index 0000000..71b4b95
--- /dev/null
+++ b/pulp_deb/app/migrations/0020_sourceindex_sourcepackage_sourcepackagereleasecomponent.py
@@ -0,0 +1,82 @@
+# Generated by Django 3.2.16 on 2022-12-15 19:29
+
+from django.db import migrations, models
+import django.db.models.deletion
+
+
+class Migration(migrations.Migration):
+
+    dependencies = [
+        ('core', '0098_pulp_labels'),
+        ('deb', '0022_auto_20221207_2130'),
+    ]
+
+    operations = [
+        migrations.CreateModel(
+            name='SourcePackage',
+            fields=[
+                ('content_ptr', models.OneToOneField(auto_created=True, on_delete=django.db.models.deletion.CASCADE, parent_link=True, primary_key=True, related_name='deb_sourcepackage', serialize=False, to='core.content')),
+                ('relative_path', models.TextField()),
+                ('format', models.TextField()),
+                ('source', models.TextField()),
+                ('binary', models.TextField(null=True)),
+                ('architecture', models.TextField(null=True)),
+                ('version', models.TextField()),
+                ('maintainer', models.TextField()),
+                ('uploaders', models.TextField(null=True)),
+                ('homepage', models.TextField(null=True)),
+                ('vcs_browser', models.TextField(null=True)),
+                ('vcs_arch', models.TextField(null=True)),
+                ('vcs_bzr', models.TextField(null=True)),
+                ('vcs_cvs', models.TextField(null=True)),
+                ('vcs_darcs', models.TextField(null=True)),
+                ('vcs_git', models.TextField(null=True)),
+                ('vcs_hg', models.TextField(null=True)),
+                ('vcs_mtn', models.TextField(null=True)),
+                ('vcs_snv', models.TextField(null=True)),
+                ('testsuite', models.TextField(null=True)),
+                ('dgit', models.TextField(null=True)),
+                ('standards_version', models.TextField()),
+                ('build_depends', models.TextField(null=True)),
+                ('build_depends_indep', models.TextField(null=True)),
+                ('build_depends_arch', models.TextField(null=True)),
+                ('build_conflicts', models.TextField(null=True)),
+                ('build_conflicts_indep', models.TextField(null=True)),
+                ('build_conflicts_arch', models.TextField(null=True)),
+                ('package_list', models.TextField(null=True)),
+            ],
+            options={
+                'default_related_name': '%(app_label)s_%(model_name)s',
+            },
+            bases=('core.content',),
+        ),
+        migrations.CreateModel(
+            name='SourcePackageReleaseComponent',
+            fields=[
+                ('content_ptr', models.OneToOneField(auto_created=True, on_delete=django.db.models.deletion.CASCADE, parent_link=True, primary_key=True, related_name='deb_sourcepackagereleasecomponent', serialize=False, to='core.content')),
+                ('release_component', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='deb_sourcepackagereleasecomponent', to='deb.releasecomponent')),
+                ('source_package', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='deb_sourcepackagereleasecomponent', to='deb.sourcepackage')),
+            ],
+            options={
+                'default_related_name': '%(app_label)s_%(model_name)s',
+                'unique_together': {('source_package', 'release_component')},
+            },
+            bases=('core.content',),
+        ),
+        migrations.CreateModel(
+            name='SourceIndex',
+            fields=[
+                ('content_ptr', models.OneToOneField(auto_created=True, on_delete=django.db.models.deletion.CASCADE, parent_link=True, primary_key=True, related_name='deb_sourceindex', serialize=False, to='core.content')),
+                ('component', models.CharField(max_length=255)),
+                ('relative_path', models.TextField()),
+                ('sha256', models.CharField(max_length=255)),
+                ('release', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='deb_sourceindex', to='deb.releasefile')),
+            ],
+            options={
+                'verbose_name_plural': 'SourceIndices',
+                'default_related_name': '%(app_label)s_%(model_name)s',
+                'unique_together': {('relative_path', 'sha256')},
+            },
+            bases=('core.content',),
+        ),
+    ]
diff --git a/pulp_deb/app/models/__init__.py b/pulp_deb/app/models/__init__.py
index b54d677..d64995e 100644
--- a/pulp_deb/app/models/__init__.py
+++ b/pulp_deb/app/models/__init__.py
@@ -5,6 +7,7 @@ from .content import (
     GenericContent,
     InstallerPackage,
     Package,
+    SourcePackage,
 )
 
 from .signing_service import AptReleaseSigningService
@@ -14,9 +13,10 @@ from .structure_content import (
     ReleaseArchitecture,
     ReleaseComponent,
     PackageReleaseComponent,
+    SourcePackageReleaseComponent,
 )
 
-from .metadata_content import ReleaseFile, PackageIndex, InstallerFileIndex
+from .metadata_content import ReleaseFile, PackageIndex, InstallerFileIndex, SourceIndex
 
 from .publication import AptDistribution, AptPublication, VerbatimPublication
 
diff --git a/pulp_deb/app/models/content.py b/pulp_deb/app/models/content.py
index ff99332..b9470e1 100644
--- a/pulp_deb/app/models/content.py
+++ b/pulp_deb/app/models/content.py
@@ -7,7 +6,6 @@ from django.db.models import JSONField
 
 from pulpcore.plugin.models import Content
 
-
 BOOL_CHOICES = [(True, "yes"), (False, "no")]
 
 
@@ -159,3 +138,172 @@ class GenericContent(Content):
     class Meta:
         default_related_name = "%(app_label)s_%(model_name)s"
         unique_together = (("relative_path", "sha256"),)
+
+
+class SourcePackage(Content):
+    """
+    The Debian Source Package (dsc, orig.tar.gz, debian.tar.gz... files) content type.
+
+    This model must contain all information that is needed to
+    generate the corresponding paragraph in "Souces" indices files.
+    """
+
+    TYPE = "source_package"
+
+    SUFFIX = "dsc"
+
+    relative_path = models.TextField()
+    format = models.TextField()  # the format of the source package
+    source = models.TextField()  # source package nameformat
+    binary = models.TextField(null=True)  # lists binary packages which a source package can produce
+    architecture = models.TextField(null=True)  # all, i386, ...
+    version = models.TextField()  # The format is: [epoch:]upstream_version[-debian_revision]
+    maintainer = models.TextField()
+    uploaders = models.TextField(null=True)  # Names and emails of co-maintainers
+    homepage = models.TextField(null=True)
+    vcs_browser = models.TextField(null=True)
+    vcs_arch = models.TextField(null=True)
+    vcs_bzr = models.TextField(null=True)
+    vcs_cvs = models.TextField(null=True)
+    vcs_darcs = models.TextField(null=True)
+    vcs_git = models.TextField(null=True)
+    vcs_hg = models.TextField(null=True)
+    vcs_mtn = models.TextField(null=True)
+    vcs_snv = models.TextField(null=True)
+    testsuite = models.TextField(null=True)
+    dgit = models.TextField(null=True)
+    standards_version = models.TextField()  # most recent version of the standards the pkg complies
+    build_depends = models.TextField(null=True)
+    build_depends_indep = models.TextField(null=True)
+    build_depends_arch = models.TextField(null=True)
+    build_conflicts = models.TextField(null=True)
+    build_conflicts_indep = models.TextField(null=True)
+    build_conflicts_arch = models.TextField(null=True)
+    package_list = models.TextField(
+        null=True
+    )  # all the packages that can be built from the source package
+
+    def __init__(self, *args, **kwargs):
+        """Sanatize kwargs by removing multi-lists before contructing DscFile"""
+        for kw in ["files", "checksums_sha1", "checksums_sha256", "checksums_sha512"]:
+            if kw in kwargs:
+                kwargs.pop(kw)
+        super().__init__(*args, **kwargs)
+
+    def derived_dsc_filename(self):
+        """Print a nice name for the Dsc file."""
+        return "{}_{}.{}".format(self.source, self.version, self.SUFFIX)
+
+    def derived_dir(self, component=""):
+        """Assemble full dir in pool directory."""
+        sourcename = self.source
+        prefix = sourcename[0]
+        return os.path.join(
+            "pool",
+            component,
+            prefix,
+            sourcename,
+        )
+
+    def derived_path(self, name, component=""):
+        """Assemble filename in pool directory."""
+        return os.path.join(self.derived_dir(component), name)
+
+    @property
+    def checksums_sha1(self):
+        """Generate 'Checksums-Sha1' list from content artifacts."""
+        contents = []
+        for content_artifact in self.contentartifact_set.all():
+            if content_artifact:
+                if content_artifact.artifact:
+                    sha1 = content_artifact.artifact.sha1
+                    size = content_artifact.artifact.size
+                else:
+                    remote_artifact = content_artifact.remoteartifact_set.first()
+                    sha1 = remote_artifact.sha1
+                    size = remote_artifact.size
+                # Sha1 is optional so filter out incomplete data
+                if sha1 is not None:
+                    contents.append(
+                        {
+                            "name": os.path.basename(content_artifact.relative_path),
+                            "sha1": sha1,
+                            "size": size,
+                        }
+                    )
+        return contents
+
+    @property
+    def checksums_sha256(self):
+        """Generate 'Checksums-Sha256' list from content artifacts."""
+        contents = []
+        for content_artifact in self.contentartifact_set.all():
+            if content_artifact:
+                if content_artifact.artifact:
+                    sha256 = content_artifact.artifact.sha256
+                    size = content_artifact.artifact.size
+                else:
+                    remote_artifact = content_artifact.remoteartifact_set.first()
+                    sha256 = remote_artifact.sha256
+                    size = remote_artifact.size
+                # Sha256 is required so better to not filter out incomplete data
+                contents.append(
+                    {
+                        "name": os.path.basename(content_artifact.relative_path),
+                        "sha256": sha256,
+                        "size": size,
+                    }
+                )
+        return contents
+
+    @property
+    def checksums_sha512(self):
+        """Generate 'Checksums-Sha512' list from content artifacts."""
+        contents = []
+        for content_artifact in self.contentartifact_set.all():
+            if content_artifact:
+                if content_artifact.artifact:
+                    sha512 = content_artifact.artifact.sha512
+                    size = content_artifact.artifact.size
+                else:
+                    remote_artifact = content_artifact.remoteartifact_set.first()
+                    sha512 = remote_artifact.sha512
+                    size = remote_artifact.size
+                # Sha512 is optional so filter out incomplete data
+                if sha512 is not None:
+                    contents.append(
+                        {
+                            "name": os.path.basename(content_artifact.relative_path),
+                            "sha512": sha512,
+                            "size": size,
+                        }
+                    )
+        return contents
+
+    @property
+    def files(self):
+        """Generate 'Files' list from content artifacts."""
+        contents = []
+        for content_artifact in self.contentartifact_set.all():
+            if content_artifact:
+                if content_artifact.artifact:
+                    md5 = content_artifact.artifact.md5
+                    size = content_artifact.artifact.size
+                else:
+                    remote_artifact = content_artifact.remoteartifact_set.first()
+                    md5 = remote_artifact.md5
+                    size = remote_artifact.size
+                # md5 is required so better to not filter out incomplete data
+                contents.append(
+                    {
+                        "name": os.path.basename(content_artifact.relative_path),
+                        "md5sum": md5,
+                        "size": size,
+                    }
+                )
+        return contents
+
+    repo_key_fields = ("source", "version")
+
+    class Meta:
+        default_related_name = "%(app_label)s_%(model_name)s"
diff --git a/pulp_deb/app/models/metadata_content.py b/pulp_deb/app/models/metadata_content.py
index f716a77..4f356ef 100644
--- a/pulp_deb/app/models/metadata_content.py
+++ b/pulp_deb/app/models/metadata_content.py
@@ -119,3 +111,33 @@ class InstallerFileIndex(Content):
         Retrieve the uncompressed SHA256SUMS artifact.
         """
         return self._artifacts.get(sha256=self.sha256)
+
+
+class SourceIndex(Content):
+    """
+    The "SourceIndex" content type.
+
+    This model represents the Sources file for a specific
+    component.
+    It's artifacts should include all (non-)compressed versions
+    of the upstream Sources file.
+    """
+
+    TYPE = "source_index"
+
+    release = models.ForeignKey(ReleaseFile, on_delete=models.CASCADE)
+    component = models.CharField(max_length=255)
+    relative_path = models.TextField()
+    sha256 = models.CharField(max_length=255)
+
+    class Meta:
+        default_related_name = "%(app_label)s_%(model_name)s"
+        verbose_name_plural = "SourceIndices"
+        unique_together = (("relative_path", "sha256"),)
+
+    @property
+    def main_artifact(self):
+        """
+        Retrieve teh uncompressed SourceIndex artifact.
+        """
+        return self._artifacts.get(sha256=self.sha256)
diff --git a/pulp_deb/app/models/repository.py b/pulp_deb/app/models/repository.py
index 1e25504..f348df2 100644
--- a/pulp_deb/app/models/repository.py
+++ b/pulp_deb/app/models/repository.py
@@ -15,6 +14,9 @@ from pulp_deb.app.models import (
     ReleaseArchitecture,
     ReleaseComponent,
     ReleaseFile,
+    SourceIndex,
+    SourcePackage,
+    SourcePackageReleaseComponent,
 )
 
 
@@ -35,6 +37,9 @@ class AptRepository(Repository):
         ReleaseArchitecture,
         ReleaseComponent,
         ReleaseFile,
+        SourceIndex,
+        SourcePackage,
+        SourcePackageReleaseComponent,
     ]
     REMOTE_TYPES = [
         AptRemote,
diff --git a/pulp_deb/app/models/structure_content.py b/pulp_deb/app/models/structure_content.py
index 4ff17a4..4f83be9 100644
--- a/pulp_deb/app/models/structure_content.py
+++ b/pulp_deb/app/models/structure_content.py
@@ -4,7 +4,7 @@ from django.db import models
 
 from pulpcore.plugin.models import Content
 
-from pulp_deb.app.models import Package
+from pulp_deb.app.models import Package, SourcePackage
 
 
 BOOL_CHOICES = [(True, "yes"), (False, "no")]
@@ -107,3 +94,21 @@ class PackageReleaseComponent(Content):
     class Meta:
         default_related_name = "%(app_label)s_%(model_name)s"
         unique_together = (("package", "release_component"),)
+
+
+class SourcePackageReleaseComponent(Content):
+    """
+    The SourcePackageReleaseComponent.
+
+    This is the join table that decides, which Source Package (in which RepositoryVersions) belong
+    to which ReleaseComponents.
+    """
+
+    TYPE = "source_package_release_component"
+
+    source_package = models.ForeignKey(SourcePackage, on_delete=models.CASCADE)
+    release_component = models.ForeignKey(ReleaseComponent, on_delete=models.CASCADE)
+
+    class Meta:
+        default_related_name = "%(app_label)s_%(model_name)s"
+        unique_together = (("source_package", "release_component"),)
diff --git a/pulp_deb/app/serializers/__init__.py b/pulp_deb/app/serializers/__init__.py
index 83cf769..539123e 100644
--- a/pulp_deb/app/serializers/__init__.py
+++ b/pulp_deb/app/serializers/__init__.py
@@ -13,6 +13,10 @@ from .content_serializers import (
     ReleaseArchitectureSerializer,
     ReleaseComponentSerializer,
     ReleaseFileSerializer,
+    SourceIndexSerializer,
+    DscFile822Serializer,
+    SourcePackageSerializer,
+    SourcePackageReleaseComponentSerializer,
 )
 
 from .publication_serializers import (
diff --git a/pulp_deb/app/serializers/content_serializers.py b/pulp_deb/app/serializers/content_serializers.py
index 8b5ef65..533931b 100644
--- a/pulp_deb/app/serializers/content_serializers.py
+++ b/pulp_deb/app/serializers/content_serializers.py
@@ -1,10 +1,11 @@
 from gettext import gettext as _
 
 import os
+from django.conf import settings
 
 from debian import deb822, debfile
 
-from rest_framework.serializers import CharField, DictField, Field, ValidationError
+from rest_framework.serializers import CharField, DictField, Field, ValidationError, Serializer
 from pulpcore.plugin.models import Artifact, RemoteArtifact
 from pulpcore.plugin.serializers import (
     ContentChecksumSerializer,
@@ -13,6 +14,7 @@ from pulpcore.plugin.serializers import (
     SingleArtifactContentSerializer,
     SingleArtifactContentUploadSerializer,
     DetailRelatedField,
+    SingleContentArtifactField,
 )
 
 from pulp_deb.app.models import (
@@ -27,6 +29,9 @@ from pulp_deb.app.models import (
     ReleaseArchitecture,
     ReleaseComponent,
     ReleaseFile,
+    SourceIndex,
+    SourcePackage,
+    SourcePackageReleaseComponent,
 )
 
 from pulp_deb.app.models.content import BOOL_CHOICES
@@ -182,6 +158,31 @@ class PackageIndexSerializer(MultipleArtifactContentSerializer):
         model = PackageIndex
 
 
+class SourceIndexSerializer(MultipleArtifactContentSerializer):
+    """
+    A serializer for SourceIndex.
+    """
+
+    component = CharField(help_text="Component this index file belongs to.", required=True)
+
+    relative_path = CharField(help_text="Path of file relative to url.", required=False)
+
+    release = DetailRelatedField(
+        help_text="Release this index file belongs to.",
+        many=False,
+        queryset=ReleaseFile.objects.all(),
+        view_name="deb-release-file-detail",
+    )
+
+    class Meta:
+        fields = MultipleArtifactContentSerializer.Meta.fields + (
+            "release",
+            "component",
+            "relative_path",
+        )
+        model = SourceIndex
+
+
 class InstallerFileIndexSerializer(MultipleArtifactContentSerializer):
     """
     A serializer for InstallerFileIndex.
@@ -715,3 +704,410 @@ class PackageReleaseComponentSerializer(NoArtifactContentSerializer):
     class Meta(NoArtifactContentSerializer.Meta):
         model = PackageReleaseComponent
         fields = NoArtifactContentSerializer.Meta.fields + ("package", "release_component")
+
+
+class SourceSha1Serializer(Serializer):
+    """
+    A Serializer for Checksums-Sha1 list.
+    """
+
+    name = CharField()
+    size = CharField()
+    sha1 = CharField(max_length=40)
+
+    class Meta:
+        fields = (
+            "sha1",
+            "size",
+            "name",
+        )
+
+
+class SourceSha256Serializer(Serializer):
+    """
+    A Serializer for Checksums-Sha256 list.
+    """
+
+    name = CharField(required=True)
+    size = CharField(required=True)
+    sha256 = CharField(max_length=64)
+
+    class Meta:
+        fields = (
+            "sha256",
+            "size",
+            "name",
+        )
+
+
+class SourceSha512Serializer(Serializer):
+    """
+    A Serializer for Checksums-Sha512 list.
+    """
+
+    name = CharField()
+    size = CharField()
+    sha512 = CharField(max_length=128)
+
+    class Meta:
+        fields = (
+            "sha512",
+            "size",
+            "name",
+        )
+
+
+class SourceMd5sumSerializer(Serializer):
+    """
+    A Serializer for Files list.
+    """
+
+    name = CharField()
+    size = CharField()
+    md5sum = CharField(max_length=32)
+
+    class Meta:
+        fields = (
+            "md5sum",
+            "size",
+            "name",
+        )
+
+
+class DscFile822Serializer(NoArtifactContentSerializer):
+    """
+    A Serializer for DscFile used for conversion to/from 822 format.
+    """
+
+    TRANSLATION_DICT = {
+        "format": "Format",
+        "source": "Source",
+        "binary": "Binary",
+        "architecture": "Architecture",
+        "version": "Version",
+        "maintainer": "Maintainer",
+        "uploaders": "Uploaders",
+        "homepage": "Homepage",
+        "vcs_browser": "Vcs-Browser",
+        "vcs_arch": "Vcs-Arch",
+        "vcs_bzr": "Vcs-Bzr",
+        "vcs_cvs": "Vcs-Cvs",
+        "vcs_darcs": "Vcs-Darcs",
+        "vcs_git": "Vcs-Git",
+        "vcs_hg": "Vcs-Hg",
+        "vcs_mtn": "Vcs-Mtn",
+        "vcs_snv": "Vcs-Svn",
+        "testsuite": "Testsuite",
+        "dgit": "Dgit",
+        "standards_version": "Standards-Version",
+        "build_depends": "Build-Depends",
+        "build_depends_indep": "Build-Depends-Indep",
+        "build_depends_arch": "Build-Depends-Arch",
+        "build_conflicts": "Build-Conflicts",
+        "build_conflicts_indep": "Build-Conflicts-Indep",
+        "build_conflicts_arch": "Build-Conflicts-Arch",
+        "package_list": "Package-List",
+        "checksums_sha1": "Checksums-Sha1",
+        "checksums_sha256": "Checksums-Sha256",
+        "checksums_sha512": "Checksums-Sha512",
+        "files": "Files",
+    }
+
+    format = CharField()
+    source = CharField()
+    binary = CharField(required=False)
+    architecture = CharField(required=False)
+    version = CharField()
+    maintainer = CharField()
+    uploaders = CharField(required=False)
+    homepage = CharField(required=False)
+    vcs_browser = CharField(required=False)
+    vcs_arch = CharField(required=False)
+    vcs_bzr = CharField(required=False)
+    vcs_cvs = CharField(required=False)
+    vcs_darcs = CharField(required=False)
+    vcs_git = CharField(required=False)
+    vcs_hg = CharField(required=False)
+    vcs_mtn = CharField(required=False)
+    vcs_snv = CharField(required=False)
+    testsuite = CharField(required=False)
+    dgit = CharField(required=False)
+    standards_version = CharField()
+    build_depends = CharField(required=False)
+    build_depends_indep = CharField(required=False)
+    build_depends_arch = CharField(required=False)
+    build_conflicts = CharField(required=False)
+    build_conflicts_indep = CharField(required=False)
+    build_conflicts_arch = CharField(required=False)
+    package_list = CharField(required=False)
+    checksums_sha1 = SourceSha1Serializer(many=True, required=False)
+    checksums_sha256 = SourceSha256Serializer(many=True)
+    checksums_sha512 = SourceSha512Serializer(many=True, required=False)
+    files = SourceMd5sumSerializer(many=True)
+
+    @classmethod
+    def from822(cls, data, **kwargs):
+        """
+        Translate deb822.Dsc to a dictionary for class instatiation. Automatically determines if
+        the incoming data is from a sources index paragraph and adjusts accordingly.
+        """
+        if "Directory" in data and "Package" in data:
+            data["Source"] = data.pop("Package")
+            data.pop("Directory")
+            if "Priority" in data:
+                data.pop("Priority")
+            if "Section" in data:
+                data.pop("Section")
+
+        return cls(
+            data={k: data[v] for k, v in cls.TRANSLATION_DICT.items() if v in data}, **kwargs
+        )
+
+    def to822(self, component="", paragraph=False):
+        """
+        Create deb822.Dsc object from model. If the 'paragraph' argument is True then the returned
+        object will be adjusted to be a valid paragraph in a source index file.
+        """
+        ret = deb822.Dsc()
+
+        # Respect ALLOWED_CONTENT_CHECKSUMS
+        all_checksums = {
+            "sha1": "checksums_sha1",
+            "sha256": "checksums_sha256",
+            "sha512": "checksums_sha512",
+            "md5": "files",
+        }
+        disallowed_checksums = {
+            k: all_checksums[k]
+            for k, v in all_checksums.items()
+            if k not in settings.ALLOWED_CONTENT_CHECKSUMS
+        }
+
+        for k, v in self.TRANSLATION_DICT.items():
+            if k in disallowed_checksums.values():
+                continue
+            value = self.data.get(k)
+            if value:
+                ret[v] = value
+
+        # DB storage strips leading newline-space from the first 'Package-List' entry, restore it.
+        if "Package-List" in ret and ret["Package-List"][0] != "\n":
+            ret["Package-List"] = "\n {}".format(ret["Package-List"])
+
+        if paragraph:
+            """
+            Used as a paragraph in the Sources indices file. Use 'Package' instead of 'Source'
+            and include 'Directory'. Currently we skip the optional 'Priority' and 'Section'.
+            """
+            ret["Package"] = ret.pop("Source")
+            ret["Directory"] = self.instance.derived_dir(component)
+
+        return ret
+
+    class Meta:
+        fields = (
+            "format",
+            "source",
+            "binary",
+            "architecture",
+            "version",
+            "maintainer",
+            "uploaders",
+            "homepage",
+            "vcs_browser",
+            "vcs_arch",
+            "vcs_bzr",
+            "vcs_cvs",
+            "vcs_darcs",
+            "vcs_git",
+            "vcs_hg",
+            "vcs_mtn",
+            "vcs_snv",
+            "testsuite",
+            "dgit",
+            "standards_version",
+            "build_depends",
+            "build_depends_indep",
+            "build_depends_arch",
+            "build_conflicts",
+            "build_conflicts_indep",
+            "build_conflicts_arch",
+            "package_list",
+            "checksums_sha1",
+            "checksums_sha256",
+            "checksums_sha512",
+            "files",
+        )
+        model = SourcePackage
+
+
+class SourcePackageSerializer(MultipleArtifactContentSerializer):
+    """
+    A Serializer for DscFile.
+    """
+
+    artifact = SingleContentArtifactField(
+        help_text=_("Artifact URL of the Debian Source Control (dsc) file."),
+        write_only=True,
+    )
+    relative_path = CharField(
+        help_text=_(
+            "Relative path of the Debian Source Control (dsc) file."
+            "It is normally advised to let Pulp generate this."
+        ),
+        required=False,
+    )
+    format = CharField(read_only=True)
+    source = CharField(read_only=True)
+    binary = CharField(read_only=True)
+    architecture = CharField(read_only=True)
+    version = CharField(read_only=True)
+    maintainer = CharField(read_only=True)
+    uploaders = CharField(read_only=True)
+    homepage = CharField(read_only=True)
+    vcs_browser = CharField(read_only=True)
+    vcs_arch = CharField(read_only=True)
+    vcs_bzr = CharField(read_only=True)
+    vcs_cvs = CharField(read_only=True)
+    vcs_darcs = CharField(read_only=True)
+    vcs_git = CharField(read_only=True)
+    vcs_hg = CharField(read_only=True)
+    vcs_mtn = CharField(read_only=True)
+    vcs_snv = CharField(read_only=True)
+    testsuite = CharField(read_only=True)
+    dgit = CharField(read_only=True)
+    standards_version = CharField(read_only=True)
+    build_depends = CharField(read_only=True)
+    build_depends_indep = CharField(read_only=True)
+    build_depends_arch = CharField(read_only=True)
+    build_conflicts = CharField(read_only=True)
+    build_conflicts_indep = CharField(read_only=True)
+    build_conflicts_arch = CharField(read_only=True)
+    package_list = CharField(read_only=True)
+
+    def __init__(self, *args, **kwargs):
+        """Initializer for DscFileSerializer."""
+        super().__init__(*args, **kwargs)
+        self.fields["artifacts"].read_only = True
+
+    def create(self, validated_data):
+        """Create DscFileSerializer"""
+        skip_keys = ["artifact", "files", "checksums_sha1", "checksums_sha256", "checksums_sha512"]
+        return super().create({k: validated_data[k] for k in validated_data if k not in skip_keys})
+
+    def validate(self, data):
+        """Validate that DscFile data."""
+        data = super().validate(data)
+
+        if "request" not in self.context:
+            data = self.deferred_validate(data)
+        return data
+
+    def deferred_validate(self, data):
+        """Validate that the artifact is a source control file and extract it's values."""
+        try:
+            source_paragraph = deb822.Dsc(data["artifact"].file)
+        except Exception:  # TODO: Be more specific
+            raise ValidationError(_("Unable to read Source Control File"))
+
+        from822_serializer = DscFile822Serializer.from822(data=source_paragraph)
+        from822_serializer.is_valid(raise_exception=True)
+        source_data = from822_serializer.validated_data
+        data.update(source_data)
+
+        """
+        Really no leeway here. 'name' and 'filename' must match contents of DSC
+        only the path component of relative_path can be adjusted (though shouldn't)
+        """
+        model = self.Meta.model(**source_data)
+        if "relative_path" not in data:
+            data["relative_path"] = model.derived_path(model.derived_dsc_filename())
+        elif not os.path.basename(data["relative_path"]) == model.derived_dsc_filename():
+            raise ValidationError(
+                _("Invalid relative_path provided '{}', filename '{}' do not match.").format(
+                    data["relative_path"], model.derived_dsc_filename()
+                )
+            )
+
+        content = SourcePackage.objects.filter(source=data["source"], version=data["version"])
+        if content.exists():
+            raise ValidationError(
+                _(
+                    "There is already a DSC file with version '{version}' and source name "
+                    "'{source}'."
+                ).format(version=data["version"], source=data["source"])
+            )
+
+        artifacts = {data["relative_path"]: data["artifact"]}
+        for source in data["checksums_sha256"]:
+            content = Artifact.objects.filter(sha256=source["sha256"], size=source["size"])
+            if not content.exists():
+                raise ValidationError(
+                    _(
+                        "A source file is listed in the DSC file but is not yet available '{name}'"
+                        " and sha256 '{sha256}'."
+                    ).format(name=source["name"], sha256=source["sha256"])
+                )
+            artifacts[
+                os.path.join(os.path.dirname(data["relative_path"]), source["name"])
+            ] = content.first()
+
+        data["artifacts"] = artifacts
+        return data
+
+    class Meta:
+        fields = MultipleArtifactContentSerializer.Meta.fields + (
+            "artifact",
+            "relative_path",
+            "format",
+            "source",
+            "binary",
+            "architecture",
+            "version",
+            "maintainer",
+            "uploaders",
+            "homepage",
+            "vcs_browser",
+            "vcs_arch",
+            "vcs_bzr",
+            "vcs_cvs",
+            "vcs_darcs",
+            "vcs_git",
+            "vcs_hg",
+            "vcs_mtn",
+            "vcs_snv",
+            "testsuite",
+            "dgit",
+            "standards_version",
+            "build_depends",
+            "build_depends_indep",
+            "build_depends_arch",
+            "build_conflicts",
+            "build_conflicts_indep",
+            "build_conflicts_arch",
+            "package_list",
+        )
+        model = SourcePackage
+
+
+class SourcePackageReleaseComponentSerializer(NoArtifactContentSerializer):
+    """
+    A Serializer for SourcePackageReleaseComponent.
+    """
+
+    source_package = DetailRelatedField(
+        help_text="Source package that is contained in release_comonent.",
+        many=False,
+        queryset=SourcePackage.objects.all(),
+        view_name="content-deb/source_packages-detail",
+    )
+    release_component = DetailRelatedField(
+        help_text="ReleaseComponent this source package is contained in.",
+        many=False,
+        queryset=ReleaseComponent.objects.all(),
+        view_name="content-deb/release_components-detail",
+    )
+
+    class Meta(NoArtifactContentSerializer.Meta):
+        model = SourcePackageReleaseComponent
+        fields = NoArtifactContentSerializer.Meta.fields + ("source_package", "release_component")
diff --git a/pulp_deb/app/tasks/publishing.py b/pulp_deb/app/tasks/publishing.py
index 1b4865a..e6847f8 100644
--- a/pulp_deb/app/tasks/publishing.py
+++ b/pulp_deb/app/tasks/publishing.py
@@ -29,9 +29,14 @@ from pulp_deb.app.models import (
     ReleaseComponent,
     VerbatimPublication,
     AptReleaseSigningService,
+    SourcePackage,
+    SourcePackageReleaseComponent,
 )
 
-from pulp_deb.app.serializers import Package822Serializer
+from pulp_deb.app.serializers import (
+    Package822Serializer,
+    DscFile822Serializer,
+)
 
 from pulp_deb.app.constants import (
     NO_MD5_WARNING_MESSAGE,
@@ -134,6 +139,12 @@ def publish(repository_version_pk, simple=False, structured=False, signing_servi
                     pk__in=repo_version.content.order_by("-pulp_created"),
                 ):
                     release_helper.components[component].add_package(package)
+
+                for source_package in SourcePackage.objects.filter(
+                    pk__in=repo_version.content.order_by("-pulp_created"),
+                ):
+                    release_helper.components[component].add_source_package(source_package)
+
                 release_helper.finish()
 
             if structured:
@@ -180,6 +191,13 @@ def publish(repository_version_pk, simple=False, structured=False, signing_servi
                         release_helper.components[prc.release_component.component].add_package(
                             prc.package
                         )
+                    for drc in SourcePackageReleaseComponent.objects.filter(
+                        pk__in=repo_version.content.order_by("-pulp_created"),
+                        release_component__in=components,
+                    ):
+                        release_helper.components[
+                            drc.release_component.component
+                        ].add_source_package(drc.source_package)
 
                     release_helper.save_unsigned_metadata()
                     release_helpers.append(release_helper)
@@ -201,6 +220,7 @@ class _ComponentHelper:
         self.component = component
         self.plain_component = os.path.basename(component)
         self.package_index_files = {}
+        self.source_index_file_info = None
 
         for architecture in self.parent.architectures:
             package_index_path = os.path.join(
@@ -215,6 +218,19 @@ class _ComponentHelper:
                 open(package_index_path, "wb"),
                 package_index_path,
             )
+        # Source indicies file
+        source_index_path = os.path.join(
+            "dists",
+            self.parent.distribution.strip("/"),
+            self.plain_component,
+            "source",
+            "Sources",
+        )
+        os.makedirs(os.path.dirname(source_index_path), exist_ok=True)
+        self.source_index_file_info = (
+            open(source_index_path, "wb"),
+            source_index_path,
+        )
 
     def add_package(self, package):
         with suppress(IntegrityError):
@@ -230,6 +246,24 @@ class _ComponentHelper:
         )
         self.package_index_files[package.architecture][0].write(b"\n")
 
+    # Publish DSC file and setup to create Sources Indices file
+    def add_source_package(self, source_package):
+        artifact_set = source_package.contentartifact_set.all()
+        for content_artifact in artifact_set:
+            published_artifact = PublishedArtifact(
+                relative_path=source_package.derived_path(
+                    os.path.basename(content_artifact.relative_path), self.component
+                ),
+                publication=self.parent.publication,
+                content_artifact=content_artifact,
+            )
+            published_artifact.save()
+        dsc_file_822_serializer = DscFile822Serializer(source_package, context={"request": None})
+        dsc_file_822_serializer.to822(self.component, paragraph=True).dump(
+            self.source_index_file_info[0]
+        )
+        self.source_index_file_info[0].write(b"\n")
+
     def finish(self):
         # Publish Packages files
         for (package_index_file, package_index_path) in self.package_index_files.values():
@@ -245,6 +279,21 @@ class _ComponentHelper:
             gz_package_index.save()
             self.parent.add_metadata(package_index)
             self.parent.add_metadata(gz_package_index)
+        # Publish Sources Indices file
+        if self.source_index_file_info is not None:
+            (source_index_file, source_index_path) = self.source_index_file_info
+            source_index_file.close()
+            gz_source_index_path = _zip_file(source_index_path)
+            source_index = PublishedMetadata.create_from_file(
+                publication=self.parent.publication, file=File(open(source_index_path, "rb"))
+            )
+            source_index.save()
+            gz_source_index = PublishedMetadata.create_from_file(
+                publication=self.parent.publication, file=File(open(gz_source_index_path, "rb"))
+            )
+            gz_source_index.save()
+            self.parent.add_metadata(source_index)
+            self.parent.add_metadata(gz_source_index)
 
 
 class _ReleaseHelper:
diff --git a/pulp_deb/app/tasks/synchronizing.py b/pulp_deb/app/tasks/synchronizing.py
index 7ef8c0d..f63534d 100644
--- a/pulp_deb/app/tasks/synchronizing.py
+++ b/pulp_deb/app/tasks/synchronizing.py
@@ -17,6 +17,8 @@ from django.conf import settings
 from django.db.utils import IntegrityError
 
 from pulpcore.plugin.exceptions import DigestValidationError
+from rest_framework.exceptions import ValidationError
+
 
 from pulpcore.plugin.models import (
     Artifact,
@@ -51,11 +53,15 @@ from pulp_deb.app.models import (
     InstallerPackage,
     AptRemote,
     AptRepository,
+    SourceIndex,
+    SourcePackage,
+    SourcePackageReleaseComponent,
 )
 
 from pulp_deb.app.serializers import (
     InstallerPackage822Serializer,
     Package822Serializer,
+    DscFile822Serializer,
 )
 
 from pulp_deb.app.constants import (
@@ -442,7 +440,7 @@ class DebUpdatePackageIndexAttributes(Stage):  # TODO: Needs a new name
             message="Update PackageIndex units", code="update.packageindex"
         ) as pb:
             async for d_content in self.items():
-                if isinstance(d_content.content, PackageIndex):
+                if isinstance(d_content.content, (PackageIndex, SourceIndex)):
                     if not d_content.d_artifacts:
                         d_content.content = None
                         d_content.resolve()
@@ -772,8 +771,11 @@ class DebFirstStage(Stage):
                     for architecture in architectures
                 ]
             )
+        # Handle source indices
         if self.remote.sync_sources:
-            raise NotImplementedError("Syncing source repositories is not yet implemented.")
+            pending_tasks.extend(
+                [self._handle_source_index(release_file, release_component, file_references)]
+            )
         await asyncio.gather(*pending_tasks)
 
     async def _handle_flat_repo(self, file_references, release_file, release):
@@ -1019,6 +1021,89 @@ class DebFirstStage(Stage):
                     )
                     await self.put(release_architecture_dc)
 
+    async def _handle_source_index(self, release_file, release_component, file_references):
+        # Create source_index
+        release_base_path = os.path.dirname(release_file.relative_path)
+        if release_file.distribution[-1] == "/":
+            # Flat repo format
+            source_index_dir = ""
+        else:
+            source_index_dir = os.path.join(release_component.plain_component, "source")
+        d_artifacts = []
+        for filename in ["Sources", "Sources.gz", "Sources.xz", "Release"]:
+            path = os.path.join(source_index_dir, filename)
+            if path in file_references:
+                relative_path = os.path.join(release_base_path, path)
+                d_artifacts.append(self._to_d_artifact(relative_path, file_references[path]))
+        if not d_artifacts:
+            # No reference here, skip this component
+            return
+        log.info(_("Downloading: {}/Sources").format(source_index_dir))
+        content_unit = SourceIndex(
+            release=release_file,
+            component=release_component.component,
+            sha256=d_artifacts[0].artifact.sha256,
+            relative_path=os.path.join(release_base_path, source_index_dir, "Sources"),
+        )
+        source_index = await self._create_unit(
+            DeclarativeContent(content=content_unit, d_artifacts=d_artifacts)
+        )
+        if not source_index:
+            log.info(
+                _("No sources index for component {}. Skipping.").format(
+                    release_component.component
+                )
+            )
+            return
+        # Interpret policy to download Artifacts or not
+        deferred_download = self.remote.policy != Remote.IMMEDIATE
+
+        # parse source_index
+        source_package_content_futures = []
+        source_index_artifact = await _get_main_artifact_blocking(source_index)
+        for source_paragraph in deb822.Sources.iter_paragraphs(source_index_artifact.file):
+            try:
+                source_dir = source_paragraph["Directory"]
+                source_relpath = os.path.join(source_dir, "blah")
+                serializer = DscFile822Serializer.from822(data=source_paragraph)
+                serializer.is_valid(raise_exception=True)
+                source_content_unit = SourcePackage(
+                    relative_path=source_relpath,
+                    **serializer.validated_data,
+                )
+                # Handle the dsc file content
+                source_das = []
+                for source_file in source_paragraph["Checksums-Sha256"]:
+                    source_relpath = os.path.join(source_dir, source_file["name"])
+                    log.debug(_("Downloading dsc content file {}.").format(source_file["name"]))
+
+                    source_path = os.path.join(self.parsed_url.path, source_relpath)
+                    source_da = DeclarativeArtifact(
+                        artifact=Artifact(
+                            size=int(source_file["size"]),
+                            **_get_source_checksums(source_paragraph, source_file["name"]),
+                        ),
+                        url=urlunparse(self.parsed_url._replace(path=source_path)),
+                        relative_path=source_relpath,
+                        remote=self.remote,
+                        deferred_download=deferred_download,
+                    )
+                    source_das.append(source_da)
+                source_dc = DeclarativeContent(content=source_content_unit, d_artifacts=source_das)
+                source_package_content_futures.append(source_dc)
+                await self.put(source_dc)
+            except (KeyError, ValidationError):
+                log.warning(_("Ignoring invalid source paragraph. {}").format(source_paragraph))
+        # Assign dsc files to this release_component
+        for source_package_content_future in source_package_content_futures:
+            source_package = await source_package_content_future.resolution()
+            source_package_release_component_dc = DeclarativeContent(
+                content=SourcePackageReleaseComponent(
+                    source_package=source_package, release_component=release_component
+                )
+            )
+            await self.put(source_package_release_component_dc)
+
     async def _handle_installer_file_index(
         self, release_file, release_component, architecture, file_references
     ):
@@ -1189,3 +1274,39 @@ def _get_checksums(unit_dict):
         for checksum_type, deb_field in CHECKSUM_TYPE_MAP.items()
         if checksum_type in settings.ALLOWED_CONTENT_CHECKSUMS and deb_field in unit_dict
     }
+
+
+def _get_source_checksums(source_paragraph, name):
+    """
+    Pulls the checksums from the various source file lists in the source index file paragraph
+    and filters the result to retain only checksum fields permitted by ALLOWED_CONTENT_CHECKSUMS.
+
+    Required checksums which are missing will cause an exception to be thrown whereas optional
+    checksums will be ignored if they are not present.
+
+    The passed in name will be used to match the line item in the list as there are guarantees
+    that the order will be preserved from list to list.
+    """
+    checksums = {}
+    # Required
+    for source_file in source_paragraph["Files"]:
+        if source_file["name"] == name:
+            checksums["md5"] = source_file["md5sum"]
+    for source_file in source_paragraph["Checksums-Sha256"]:
+        if source_file["name"] == name:
+            checksums["sha256"] = source_file["sha256"]
+    # Optional
+    if "Checksums-Sha1" in source_paragraph:
+        for source_file in source_paragraph["Checksums-Sha1"]:
+            if source_file["name"] == name:
+                checksums["sha1"] = source_file["sha1"]
+    if "Checksums-Sha512" in source_paragraph:
+        for source_file in source_paragraph["Checksums-Sha512"]:
+            if source_file["name"] == name:
+                checksums["sha512"] = source_file["sha512"]
+
+    return {
+        checksum_type: checksums[checksum_type]
+        for checksum_type in settings.ALLOWED_CONTENT_CHECKSUMS
+        if checksum_type in checksums
+    }
diff --git a/pulp_deb/app/viewsets/__init__.py b/pulp_deb/app/viewsets/__init__.py
index b65a9a3..6ca2e65 100644
--- a/pulp_deb/app/viewsets/__init__.py
+++ b/pulp_deb/app/viewsets/__init__.py
@@ -11,6 +11,9 @@ from .content import (
     ReleaseArchitectureViewSet,
     ReleaseComponentViewSet,
     ReleaseFileViewSet,
+    SourceIndexViewSet,
+    SourcePackageViewSet,
+    SourcePackageReleaseComponentViewSet,
 )
 
 from .publication import AptDistributionViewSet, AptPublicationViewSet, VerbatimPublicationViewSet
diff --git a/pulp_deb/app/viewsets/content.py b/pulp_deb/app/viewsets/content.py
index a2e14d5..796dbe0 100644
--- a/pulp_deb/app/viewsets/content.py
+++ b/pulp_deb/app/viewsets/content.py
@@ -298,6 +186,36 @@ class PackageIndexViewSet(ContentViewSet):
     filterset_class = PackageIndexFilter
 
 
+class SourceIndexFilter(ContentFilter):
+    """
+    FilterSet for SourceIndex.
+    """
+
+    class Meta:
+        model = models.SourceIndex
+        fields = ["component", "relative_path", "sha256"]
+
+
+class SourceIndexViewSet(ContentViewSet):
+    # The doc string is a top level element of the user facing REST API documentation:
+    """
+    A SourceIndex represents the source indices of a single component.
+
+    Associated artifacts: Exactly one 'Sources' file. May optionally include one or more of
+    'Sources.gz', 'Sources.xz', 'Release'. If included, the 'Release' file is a legacy
+    per-component-and-architecture Release file (with architecture always being 'source').
+
+    Note: The verbatim publisher will republish all associated artifacts, while the APT publisher
+    (both simple and structured mode) will generate any 'Sources' files it needs when creating the
+    publication. It does not make use of SourceIndex content.
+    """
+
+    endpoint_name = "source_indices"
+    queryset = models.SourceIndex.objects.all()
+    serializer_class = serializers.SourceIndexSerializer
+    filterset_class = SourceIndexFilter
+
+
 class InstallerFileIndexFilter(ContentFilter):
     """
     FilterSet for InstallerFileIndex.
@@ -455,3 +353,82 @@ class PackageReleaseComponentViewSet(ContentViewSet):
     queryset = models.PackageReleaseComponent.objects.all()
     serializer_class = serializers.PackageReleaseComponentSerializer
     filterset_class = PackageReleaseComponentFilter
+
+
+class SourcePackageFilter(ContentFilter):
+    """
+    FilterSet for Debian Source Packages.
+    """
+
+    class Meta:
+        model = models.SourcePackage
+        fields = [
+            "format",
+            "source",
+            "binary",
+            "architecture",
+            "version",
+            "maintainer",
+            "uploaders",
+            "homepage",
+            "relative_path",
+            "vcs_browser",
+            "vcs_arch",
+            "vcs_bzr",
+            "vcs_cvs",
+            "vcs_darcs",
+            "vcs_git",
+            "vcs_hg",
+            "vcs_mtn",
+            "vcs_snv",
+            "testsuite",
+            "dgit",
+            "standards_version",
+            "build_depends",
+            "build_depends_indep",
+            "build_depends_arch",
+            "build_conflicts",
+            "build_conflicts_indep",
+            "build_conflicts_arch",
+            "package_list",
+        ]
+
+
+class SourcePackageViewSet(SingleArtifactContentUploadViewSet):
+    # The doc string is a top level element of the user facing REST API documentation:
+    """
+    A Debian Source Package file represents a '.dsc' file along with its associated
+    artifacts such as orig.tar.gz, debian.tar.gz...
+
+    Associated artifacts: Exactly one '.dsc' file.
+    """
+
+    endpoint_name = "source_packages"
+    queryset = models.SourcePackage.objects.prefetch_related("_artifacts")
+    serializer_class = serializers.SourcePackageSerializer
+    filterset_class = SourcePackageFilter
+
+
+class SourcePackageReleaseComponentFilter(ContentFilter):
+    """
+    FilterSet for SourcePackageReleaseComponent.
+    """
+
+    class Meta:
+        model = models.SourcePackageReleaseComponent
+        fields = ["source_package", "release_component"]
+
+
+class SourcePackageReleaseComponentViewSet(ContentViewSet):
+    # The doc string is a top level element of the user facing REST API documentation:
+    """
+    A SourcePackageReleaseComponent associates a SourcePackage with a ReleaseComponent.
+
+    Associated artifacts: None; contains only metadata.
+
+    This simply stores the information on which source packages are part of which components.
+    """
+
+    endpoint_name = "source_release_components"
+    queryset = models.SourcePackageReleaseComponent.objects.all()
+    serializer_class = serializers.SourcePackageReleaseComponentSerializer
+    filterset_class = SourcePackageReleaseComponentFilter
-- 
2.34.1

