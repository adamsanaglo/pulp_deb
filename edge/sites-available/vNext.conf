##
# You should look at the following URL's in order to grasp a solid understanding
# of Nginx configuration files in order to fully unleash the power of Nginx.
# https://www.nginx.com/resources/wiki/start/
# https://www.nginx.com/resources/wiki/start/topics/tutorials/config_pitfalls/
# https://wiki.debian.org/Nginx/DirectoryStructure
#
# Please see /usr/share/doc/nginx-doc/examples/ for more detailed examples.
##

# Default server configuration to be deployed as
# /etc/nginx/sites-available/default
#

proxy_cache_path /mnt/cache levels=1:2 keys_zone=my_cache:10m max_size=240g inactive=168h use_temp_path=off;

server {
	listen 80 default_server;
	listen [::]:80 default_server;

	server_name packages.microsoft.com;

    # SSL configuration copied from vCurrent mirror
    listen 443 default_server ssl;

    ssl_certificate /etc/ssl/certs/pmc-ssl.cer;
    ssl_certificate_key /etc/ssl/private/pmc-ssl.key;

    # Use strong ssl security config from: https://sslscanner/Implementation.aspx
    ssl_protocols TLSv1.2;
    ssl_prefer_server_ciphers on;
    ssl_ciphers ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:AES256-GCM-SHA384:AES128-GCM-SHA256:AES256-SHA256:AES128-SHA256:AES256-SHA:AES128-SHA;
    ssl_ecdh_curve secp384r1; # Requires nginx >= 1.1.0
    ssl_session_cache shared:SSL:10m;
    ssl_session_tickets off; # Requires nginx >= 1.5.9
    ssl_stapling on; # Requires nginx >= 1.3.7
    ssl_stapling_verify on; # Requires nginx => 1.3.7
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header X-Content-Type-Options nosniff;

    # The index module translates requests for path/ to path/index.html
    # via internal redirect. The pulp origin doesn't expose index.html; if
    # you want an index, you have to request it via terminal slash.
	# index index.html index.htm index.nginx-debian.html;

    # There are a few extra headers we always want to ignore from the client
    # and hide when proxying to the origin.
    proxy_ignore_headers Set-Cookie;
    proxy_ignore_headers Cache-Control;
    proxy_ignore_headers Expires;
    proxy_hide_header Set-Cookie;      
    proxy_hide_header Cache-Control;     
    proxy_hide_header Expires;   

    # If we can't contact the origin when asked to serve content we think
    # is stale, just serve it anyway. If origin is unavailable, nothing new
    # is being published anyway.
    proxy_cache_use_stale  error timeout invalid_header updating http_500 http_502 http_503 http_504;

    # Default location is intended to apply to package files only. The goal
    # is to cache them "forever"; packages are immutable.
	location / {
		proxy_cache my_cache;
        proxy_cache_key $uri;
		proxy_pass https://pmc-distro.trafficmanager.net;
        proxy_intercept_errors on;
        error_page 301 302 307 = @handle_redirects;
        proxy_cache_valid 200 206 1y;
	}

    # Return 404 for cld files since we don't serve these files but we get lots of requests
    location ~* .*\.cld$ {
        return 404;
    }

    # Mitigate incident 349663499 / https://msazure.visualstudio.com/One/_workitems/edit/16306468
    # by serving azurecore / azurecore-test from vCurrent
    location ~* /repos/azurecore(-test)?/.*$ {
        autoindex on;
        root /var/www/html/;
	}

    # Five buckets of requests should be cached with shorter TTLs:
    # 1. RPM metadata (repodata)
    # 2. APT metadata files (Packages, etc.)
    # 3. Directory listings
    # 4. FILE_MANIFEST files
    # 5. Some ClamAV signature files

    # RPM metadata
    location ~* .*/repodata/repomd\.xml.*$ {
        proxy_cache my_cache;
        proxy_cache_key $uri;
        proxy_pass https://pmc-distro.trafficmanager.net;
        proxy_intercept_errors on;
        error_page 301 302 307 = @handle_redirects_lowttl;
        proxy_cache_valid 200 206 5m;
    }

    # APT metadata
    location ~* .*/dists/.*$ {
        proxy_cache my_cache;
        proxy_cache_key $uri;
        proxy_pass https://pmc-distro.trafficmanager.net;
        proxy_intercept_errors on;
        error_page 301 302 307 = @handle_redirects_lowttl;
        proxy_cache_valid 200 206 5m;
    }

    # Directory listings
    location ~* .*/$ {
        proxy_cache my_cache;
        proxy_cache_key $uri;
        proxy_pass https://pmc-distro.trafficmanager.net;
        proxy_intercept_errors on;
        error_page 301 302 307 = @handle_redirects_lowttl;
        proxy_cache_valid 200 206 5m;
    }

    # FILE_MANIFEST files
    location ~* .*/FILE_MANIFEST$ {
        proxy_cache my_cache;
        proxy_cache_key $uri;
        proxy_pass https://pmc-distro.trafficmanager.net;
        proxy_intercept_errors on;
        error_page 301 302 307 = @handle_redirects_lowttl;
        proxy_cache_valid 200 206 5m;
    }

    # ClamAV signature files
    location ~* /clamav/(daily|main).cvd$ {
        proxy_cache my_cache;
        proxy_cache_key $uri;
        proxy_pass https://pmc-distro.trafficmanager.net;
        proxy_intercept_errors on;
        error_page 301 302 307 = @handle_redirects_mediumttl;
        proxy_cache_valid 200 206 1h;
    }

    location @handle_redirects {
        # Capture the original request URI so we know where to cache the
        # actual content.
        # Capture the target of the redirect so we proxy to it.
        set $original_uri $uri;
        set $orig_loc $upstream_http_location;

        # Fetch the content from the upstream Location header
        proxy_pass $orig_loc;
        proxy_cache my_cache;
        # Store the result with the cache key of the original request URI
        proxy_cache_key $original_uri;
        proxy_cache_valid 200 206 1y;

        resolver 168.63.129.16; # Azure internal DNS server
    }

    location @handle_redirects_lowttl {
        # Just like @handle_redirects, but with a lower TTL for objects
        # that change when new packages are published
        set $original_uri $uri;
        set $orig_loc $upstream_http_location;

        proxy_pass $orig_loc;
        proxy_cache my_cache;

        proxy_cache_key $original_uri;
        proxy_cache_valid 200 206 5m; # 5 minute TTL

        resolver 168.63.129.16; # Azure internal DNS server
    }

    location @handle_redirects_mediumttl {
        # Just like @handle_redirects, but with a medium TTL for objects
        # that change infrequently
        set $original_uri $uri;
        set $orig_loc $upstream_http_location;

        proxy_pass $orig_loc;
        proxy_cache my_cache;

        proxy_cache_key $original_uri;
        proxy_cache_valid 200 206 1h; # One hour TTL

        resolver 168.63.129.16; # Azure internal DNS server
    }
}
