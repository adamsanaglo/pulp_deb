# PMC v4 server configuration to be deployed as
# /etc/nginx/sites-available/vNext.conf

# Cache configuration for the specific SKU this instance is running on,
# deployed at the same time this config file was deployed.
include /etc/nginx/cache.conf;

resolver 168.63.129.16; # Azure internal DNS server

upstream pulp_nginx {
    server pmc-distro.trafficmanager.net:443 weight=4000000000;
    server pmc-distro.trafficmanager.net:443;
    server pmc-distro.trafficmanager.net:443;
    server pmc-distro.trafficmanager.net:443;
}

server {
	listen 80 default_server;
	listen [::]:80 default_server;

	server_name packages.microsoft.com;

    # SSL configuration copied from vCurrent mirror
    listen 443 default_server ssl;

    ssl_certificate /etc/ssl/certs/pmc-ssl.cer;
    ssl_certificate_key /etc/ssl/private/pmc-ssl.key;
    ssl_trusted_certificate /etc/ssl/certs/pmc-ssl.cer;

    # Use strong ssl security config from: https://sslscanner/Implementation.aspx
    ssl_protocols TLSv1.2;
    ssl_prefer_server_ciphers on;
    ssl_ciphers ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:AES256-GCM-SHA384:AES128-GCM-SHA256:AES256-SHA256:AES128-SHA256:AES256-SHA:AES128-SHA;
    ssl_ecdh_curve secp384r1; # Requires nginx >= 1.1.0
    ssl_session_cache shared:SSL:10m;
    ssl_session_tickets off; # Requires nginx >= 1.5.9
    ssl_stapling on; # Requires nginx >= 1.3.7
    ssl_stapling_verify on; # Requires nginx => 1.3.7
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header X-Content-Type-Options nosniff;
    add_header X-PMC-Cache-Status $upstream_cache_status;

    # The index module translates requests for path/ to path/index.html
    # via internal redirect. The pulp origin doesn't expose index.html; if
    # you want an index, you have to request it via terminal slash.
	# index index.html index.htm index.nginx-debian.html;

    # There are a few extra headers we always want to ignore from the client
    # and hide when proxying to the origin.
    proxy_ignore_headers Set-Cookie;
    proxy_ignore_headers Cache-Control;
    proxy_ignore_headers Expires;
    proxy_hide_header Set-Cookie;      
    proxy_hide_header Cache-Control;     
    proxy_hide_header Expires;   
    proxy_connect_timeout       300;
    proxy_send_timeout          300;
    proxy_read_timeout          300;
    send_timeout                300;

    # If we can't contact the origin when asked to serve content we think
    # is stale, just serve it anyway. If origin is unavailable, nothing new
    # is being published anyway.
    proxy_cache_use_stale  error timeout invalid_header updating http_500 http_502 http_503 http_504;

    # Serve a custom landing page at /
    location ~* ^/$ {
        root /var/pmc/www;
        index index.html;
    }

    location /index.html {
        root /var/pmc/www;
    }

    # Default location is intended to apply to package files only. The goal
    # is to cache them "forever"; packages are immutable.
    location / {
        proxy_cache my_cache;
        proxy_cache_key $uri;
        proxy_pass https://pulp_nginx;
        proxy_intercept_errors on;
        error_page 301 302 307 = @handle_redirects;
        proxy_next_upstream http_502 http_504;
        proxy_cache_valid 200 206 1y;
    }

    # Return 404 for these few patterns since we don't serve these files but we get lots of requests
    location ~* ^/(clamav/)?[^/]+\.(cld|cdiff)$ {
        return 404;
    }
    location ~* .*/media\.1/media$ {
        return 404;
    }

    # Manage our own lookaside cache for APT metadata to minimize the window during which
    # an update could cause a client to see "torn" metadata (desync'd Release vs */Packages)
    location ~* .*/dists/.*$ {
        root /var/pmc/www;
        autoindex on;
    }

    # Four buckets of requests should be cached with shorter TTLs:
    # 1. RPM metadata (repodata)
    # 2. Directory listings
    # 3. FILE_MANIFEST files
    # 4. Some ClamAV signature files

    # RPM metadata
    location ~* .*/repodata/repomd\.xml.*$ {
        proxy_cache my_cache;
        proxy_cache_key $uri;
        proxy_pass https://pulp_nginx;
        proxy_intercept_errors on;
        error_page 301 302 307 = @handle_redirects_lowttl;
        proxy_next_upstream http_502 http_504;
        proxy_cache_valid 200 206 5m;
    }

    # Directory listings
    location ~* ^/.+/$ {
        proxy_cache my_cache;
        proxy_cache_key $uri;
        proxy_pass https://pulp_nginx;
        proxy_intercept_errors on;
        error_page 301 302 307 = @handle_redirects_lowttl;
        proxy_next_upstream http_502 http_504;
        proxy_cache_valid 200 206 5m;
    }

    # FILE_MANIFEST files
    location ~* .*/FILE_MANIFEST$ {
        proxy_cache my_cache;
        proxy_cache_key $uri;
        proxy_pass https://pulp_nginx;
        proxy_intercept_errors on;
        error_page 301 302 307 = @handle_redirects_lowttl;
        proxy_next_upstream http_502 http_504;
        proxy_cache_valid 200 206 5m;
    }

    # ClamAV signature files
    location ~* /clamav/(daily|main).cvd$ {
        proxy_cache my_cache;
        proxy_cache_key $uri;
        proxy_pass https://pulp_nginx;
        proxy_intercept_errors on;
        error_page 301 302 307 = @handle_redirects_mediumttl;
        proxy_next_upstream http_502 http_504;
        proxy_cache_valid 200 206 1h;
    }

    location @handle_redirects {
        # Capture the original request URI so we know where to cache the
        # actual content.
        # Capture the target of the redirect so we proxy to it.
        set $original_uri $uri;
        set $orig_loc $upstream_http_location;
        proxy_next_upstream http_502 http_504;

        # Fetch the content from the upstream Location header
        if ($orig_loc ~* "pmc-distro|blob.core") {
            # Redirect URL includes the hostname
            proxy_pass $orig_loc;
        }

        if ($orig_loc !~* "pmc-distro|blob.core"){
            # Pulp omitted the hostname from this redirect, which means it's a directory.
            # Send a redirect
            return 301 $scheme://$host$request_uri/;
        }
        proxy_cache my_cache;
        # Store the result with the cache key of the original request URI
        proxy_cache_key $original_uri;
        proxy_cache_valid 200 206 1y;
    }

    location @handle_redirects_lowttl {
        # Just like @handle_redirects, but with a lower TTL for objects
        # that change when new packages are published
        set $original_uri $uri;
        set $orig_loc $upstream_http_location;
        proxy_next_upstream http_502 http_504;

        if ($orig_loc ~* "pmc-distro|blob.core") {
            # Redirect URL includes the hostname
            proxy_pass $orig_loc;
        }

        if ($orig_loc !~* "pmc-distro|blob.core"){
            # Pulp omitted the hostname from this redirect, which means it's a directory.
            # Send a redirect
            return 301 $scheme://$host$request_uri/;
        }
        proxy_cache my_cache;

        proxy_cache_key $original_uri;
        proxy_cache_valid 200 206 5m; # 5 minute TTL
    }

    location @handle_redirects_mediumttl {
        # Just like @handle_redirects, but with a medium TTL for objects
        # that change infrequently
        set $original_uri $uri;
        set $orig_loc $upstream_http_location;
        proxy_next_upstream http_502 http_504;

        if ($orig_loc ~* "pmc-distro|blob.core") {
            # Redirect URL includes the hostname
            proxy_pass $orig_loc;
        }

        if ($orig_loc !~* "pmc-distro|blob.core"){
            # Pulp omitted the hostname from this redirect, which means it's a directory.
            # Send a redirect
            return 301 $scheme://$host$request_uri/;
        }
        proxy_cache my_cache;

        proxy_cache_key $original_uri;
        proxy_cache_valid 200 206 1h; # One hour TTL
    }

    location @handle_redirects_nocache {
        # Just like @handle_redirects, but don't cache at all
        # that change when new packages are published
        set $original_uri $uri;
        set $orig_loc $upstream_http_location;
        proxy_no_cache 1;
        proxy_cache_bypass 1;

        if ($orig_loc ~* "pmc-distro|blob.core") {
            # Redirect URL includes the hostname
            proxy_pass $orig_loc;
        }

        if ($orig_loc !~* "pmc-distro|blob.core"){
            # Pulp omitted the hostname from this redirect, which means it's a directory.
            # Send a redirect
            return 301 $scheme://$host$request_uri/;
        }

        resolver 168.63.129.16; # Azure internal DNS server
    }
}
